# ServerFunctions.jl - Server function protocol for client→server RPC calls
#
# Provides leptos-style server functions that can be called from client code.
# Server functions execute on the server and return results to the client.
#
# ============================================================================
# PROTOCOL SPECIFICATION (RFC-style)
# ============================================================================
#
# 1. WIRE PROTOCOL
#    Server functions use the existing Therapy.jl WebSocket infrastructure.
#    All messages are JSON-encoded.
#
# 2. REQUEST FORMAT (client → server)
#    {
#        "type": "server_function_call",
#        "id": "<unique-request-id>",           // For correlating response
#        "function": "<registered-function-name>",
#        "args": [<arg1>, <arg2>, ...]          // Positional args (JSON serialized)
#    }
#
#    - `id`: UUID string generated by client, used to match response
#    - `function`: String name of registered server function
#    - `args`: Array of JSON-serialized arguments in positional order
#
# 3. RESPONSE FORMAT (server → client)
#
#    Success:
#    {
#        "type": "server_function_result",
#        "id": "<request-id>",                  // Matches request id
#        "success": true,
#        "result": <json-serialized-result>
#    }
#
#    Error:
#    {
#        "type": "server_function_result",
#        "id": "<request-id>",
#        "success": false,
#        "error": {
#            "code": "<error-code>",            // "not_found", "validation", "execution"
#            "message": "<human-readable-error>"
#        }
#    }
#
# 4. ERROR CODES
#    - "not_found": Function name not registered
#    - "validation": Argument count/type mismatch
#    - "execution": Exception during function execution
#    - "timeout": Function execution exceeded timeout (future)
#
# 5. SERIALIZATION
#    - Arguments and results use JSON3 for serialization
#    - Primitive types: Int, Float64, String, Bool, Nothing → direct JSON
#    - Arrays: Vector{T} → JSON arrays
#    - Dicts: Dict{String,T} → JSON objects
#    - Structs: Custom types need JSON3.StructTypes registration
#    - Unsupported: Functions, IO, Task, etc. will error
#
# 6. SECURITY CONSIDERATIONS
#    - Only explicitly registered functions are callable
#    - Server validates argument count before execution
#    - Functions execute in server context with full permissions
#    - No sandboxing by default (user responsibility)
#
# ============================================================================
# USAGE EXAMPLE
# ============================================================================
#
#   # Server-side: Register functions
#   register_server_function("get_user", (id::Int) -> DB.query("SELECT * FROM users WHERE id = ?", id))
#   register_server_function("create_post", (title::String, body::String) -> DB.insert(...))
#
#   # Or use @server macro (THERAPY-022):
#   @server function get_user(id::Int)
#       DB.query("SELECT * FROM users WHERE id = ?", id)
#   end
#
#   # Client-side: Call via WebSocket
#   TherapyWS.callServer("get_user", [123]).then(user => console.log(user));
#
# ============================================================================

using JSON3
using UUIDs

# ============================================================================
# SERVER FUNCTION REGISTRY
# ============================================================================

"""
    ServerFunction

Metadata for a registered server function.

# Fields
- `name::String`: Unique function name for RPC calls
- `func::Function`: The actual Julia function to execute
- `arg_count::Int`: Expected number of arguments (-1 for varargs)
- `description::String`: Optional documentation
"""
struct ServerFunction
    name::String
    func::Function
    arg_count::Int
    description::String
end

# Global registry of server functions
# Maps function name -> ServerFunction
const SERVER_FUNCTIONS = Dict{String, ServerFunction}()

"""
    register_server_function(name::String, func::Function; description::String="")

Register a function to be callable from the client via WebSocket.

# Arguments
- `name`: Unique identifier for the function (used in RPC calls)
- `func`: Julia function to execute
- `description`: Optional documentation string

# Example
```julia
register_server_function("add_numbers", (a, b) -> a + b)
register_server_function("get_user", get_user_from_db; description="Fetch user by ID")
```

# Notes
- Function names must be unique; re-registering overwrites
- Functions should be pure or have controlled side effects
- Return values must be JSON-serializable
"""
function register_server_function(name::String, func::Function; description::String="")
    # Attempt to determine argument count from method signatures
    arg_count = try
        # Get the methods for this function
        methods_list = methods(func)
        if length(methods_list) == 1
            # Single method - get its arity
            m = first(methods_list)
            # nargs includes the function itself, so subtract 1
            Int(m.nargs) - 1
        else
            # Multiple methods or no methods - use varargs
            -1
        end
    catch
        -1  # Fallback to varargs
    end

    SERVER_FUNCTIONS[name] = ServerFunction(name, func, arg_count, description)
    @info "Registered server function" name=name arg_count=arg_count
    return nothing
end

"""
    unregister_server_function(name::String)

Remove a server function from the registry.
"""
function unregister_server_function(name::String)
    if haskey(SERVER_FUNCTIONS, name)
        delete!(SERVER_FUNCTIONS, name)
        @info "Unregistered server function" name=name
        return true
    end
    return false
end

"""
    list_server_functions()

Return list of all registered server function names.
"""
function list_server_functions()
    return collect(keys(SERVER_FUNCTIONS))
end

"""
    get_server_function(name::String)

Get a registered server function by name, or nothing if not found.
"""
function get_server_function(name::String)
    return get(SERVER_FUNCTIONS, name, nothing)
end

# ============================================================================
# WEBSOCKET MESSAGE HANDLING
# ============================================================================

"""
    handle_server_function_call(conn::WSConnection, msg::Dict{String, Any})

Handle an incoming server function call from a WebSocket client.

This function is called by the WebSocket message handler when a message
of type "server_function_call" is received.

# Protocol
Expects message format:
```json
{
    "type": "server_function_call",
    "id": "uuid-string",
    "function": "function_name",
    "args": [arg1, arg2, ...]
}
```

Sends response format:
```json
{
    "type": "server_function_result",
    "id": "uuid-string",
    "success": true/false,
    "result": <value>  // if success
    "error": {"code": "...", "message": "..."}  // if failure
}
```
"""
function handle_server_function_call(conn, msg::Dict{String, Any})
    # Extract request fields
    request_id = get(msg, "id", string(uuid4()))
    func_name = get(msg, "function", nothing)
    args = get(msg, "args", [])

    # Validate request
    if func_name === nothing
        send_server_function_error(conn, request_id, "validation", "Missing 'function' field")
        return
    end

    # Look up function
    server_func = get_server_function(func_name)
    if server_func === nothing
        send_server_function_error(conn, request_id, "not_found", "Function '$func_name' not registered")
        return
    end

    # Validate argument count (if known)
    if server_func.arg_count >= 0 && length(args) != server_func.arg_count
        send_server_function_error(
            conn, request_id, "validation",
            "Function '$func_name' expects $(server_func.arg_count) arguments, got $(length(args))"
        )
        return
    end

    # Execute function
    try
        result = server_func.func(args...)
        send_server_function_result(conn, request_id, result)
    catch e
        error_msg = sprint(showerror, e)
        @warn "Server function execution error" func=func_name error=error_msg
        send_server_function_error(conn, request_id, "execution", error_msg)
    end
end

"""
    send_server_function_result(conn, request_id::String, result)

Send a successful server function result to the client.
"""
function send_server_function_result(conn, request_id::String, result)
    msg = Dict{String, Any}(
        "type" => "server_function_result",
        "id" => request_id,
        "success" => true,
        "result" => result
    )
    send_ws_message(conn, msg)
end

"""
    send_server_function_error(conn, request_id::String, code::String, message::String)

Send a server function error to the client.
"""
function send_server_function_error(conn, request_id::String, code::String, message::String)
    msg = Dict{String, Any}(
        "type" => "server_function_result",
        "id" => request_id,
        "success" => false,
        "error" => Dict{String, Any}(
            "code" => code,
            "message" => message
        )
    )
    send_ws_message(conn, msg)
end

# ============================================================================
# CLIENT-SIDE JAVASCRIPT GENERATION
# ============================================================================

"""
    server_functions_client_script()

Generate client-side JavaScript for calling server functions.

This extends the TherapyWS API with:
- `TherapyWS.callServer(name, args)` - Returns Promise with result
- Automatic request ID generation
- Promise-based response handling
- Error propagation

# Example
```javascript
// Call a server function
const user = await TherapyWS.callServer("get_user", [123]);
console.log(user.name);

// Handle errors
try {
    const result = await TherapyWS.callServer("risky_operation", []);
} catch (error) {
    console.error("Server error:", error.code, error.message);
}
```
"""
function server_functions_client_script()
    RawHtml("""
<script>
// Therapy.jl Server Functions Client
(function() {
    'use strict';

    // Pending requests waiting for response
    // Maps request_id -> { resolve, reject, timeout }
    const pendingRequests = new Map();

    // Default timeout for server function calls (30 seconds)
    const DEFAULT_TIMEOUT = 30000;

    /**
     * Generate a unique request ID
     */
    function generateRequestId() {
        return 'sf_' + Date.now().toString(36) + '_' + Math.random().toString(36).substr(2, 9);
    }

    /**
     * Call a server function and return a Promise with the result
     *
     * @param {string} functionName - Name of the registered server function
     * @param {Array} args - Arguments to pass to the function
     * @param {number} timeout - Timeout in milliseconds (default: 30000)
     * @returns {Promise} - Resolves with result or rejects with error
     *
     * @example
     * const user = await TherapyWS.callServer("get_user", [123]);
     * const sum = await TherapyWS.callServer("add", [1, 2, 3]);
     */
    function callServer(functionName, args = [], timeout = DEFAULT_TIMEOUT) {
        return new Promise((resolve, reject) => {
            if (!window.TherapyWS || !window.TherapyWS.isConnected()) {
                reject({
                    code: 'not_connected',
                    message: 'WebSocket not connected'
                });
                return;
            }

            const requestId = generateRequestId();

            // Set up timeout
            const timeoutId = setTimeout(() => {
                if (pendingRequests.has(requestId)) {
                    pendingRequests.delete(requestId);
                    reject({
                        code: 'timeout',
                        message: 'Server function call timed out'
                    });
                }
            }, timeout);

            // Store pending request
            pendingRequests.set(requestId, {
                resolve: resolve,
                reject: reject,
                timeout: timeoutId
            });

            // Send request
            window.TherapyWS.send({
                type: 'server_function_call',
                id: requestId,
                function: functionName,
                args: args
            });

            console.log('[ServerFn] Calling:', functionName, args);
        });
    }

    /**
     * Handle server function result message
     * Called by TherapyWS message handler
     */
    function handleServerFunctionResult(msg) {
        const requestId = msg.id;
        const pending = pendingRequests.get(requestId);

        if (!pending) {
            console.warn('[ServerFn] Received result for unknown request:', requestId);
            return;
        }

        // Clear timeout
        clearTimeout(pending.timeout);
        pendingRequests.delete(requestId);

        if (msg.success) {
            console.log('[ServerFn] Result:', msg.result);
            pending.resolve(msg.result);
        } else {
            console.error('[ServerFn] Error:', msg.error);
            pending.reject(msg.error);
        }
    }

    // Extend TherapyWS with server function support
    // Wait for TherapyWS to be defined
    function extendTherapyWS() {
        if (window.TherapyWS) {
            window.TherapyWS.callServer = callServer;
            window.TherapyWS._handleServerFunctionResult = handleServerFunctionResult;
            console.log('[ServerFn] Server functions API ready');
        } else {
            // Wait for TherapyWS to be defined
            setTimeout(extendTherapyWS, 50);
        }
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', extendTherapyWS);
    } else {
        extendTherapyWS();
    }
})();
</script>
""")
end

# ============================================================================
# @server MACRO
# ============================================================================

"""
    @server function name(args...) ... end

Macro to define a server function that can be called from the client.

This macro does two things:
1. Defines the function normally for server-side execution
2. Registers it with the server function registry

# Syntax
```julia
@server function get_user(id::Int)
    DB.query("SELECT * FROM users WHERE id = ?", id)
end

@server function create_post(title::String, body::String)::Post
    DB.insert("posts", title=title, body=body)
end
```

# How It Works
- **Server-side**: The function is defined and registered, ready to handle RPC calls
- **Client-side**: Clients call `TherapyWS.callServer("function_name", [args...])`
  which returns a Promise with the result

# Arguments
Arguments must be JSON-serializable:
- Primitive types: Int, Float64, String, Bool, Nothing
- Collections: Vector, Dict{String, T}
- Custom structs: Must be JSON3-serializable

# Return Values
Return values are JSON-serialized and sent back to the client.

# Example
```julia
# Server-side: Define server functions
@server function add_numbers(a::Number, b::Number)
    a + b
end

@server function get_todos()::Vector{Dict{String, Any}}
    DB.query("SELECT * FROM todos")
end

# Client-side (JavaScript):
# const sum = await TherapyWS.callServer("add_numbers", [1, 2]);
# const todos = await TherapyWS.callServer("get_todos", []);
```

# Notes
- Function names must be unique across all @server functions
- Functions execute with full server permissions (no sandboxing)
- Errors during execution are caught and returned to the client
- The function is also available to call directly from server-side Julia code
"""
macro server(expr)
    # Parse the function definition
    # Check if it's a function definition (either :function or :(=) form)
    is_function = expr isa Expr && expr.head == :function
    is_short_form = expr isa Expr && expr.head == :(=) && expr.args[1] isa Expr && expr.args[1].head == :call

    if !is_function && !is_short_form
        error("@server expects a function definition")
    end

    # Extract function name and signature
    if is_function
        # function name(...) ... end
        sig = expr.args[1]
    else
        # name(...) = ...
        sig = expr.args[1]
    end

    # Handle optional return type annotation: name(args...)::ReturnType
    if sig isa Expr && sig.head == :(::)
        # Has return type annotation
        call_expr = sig.args[1]
    else
        call_expr = sig
    end

    # Verify it's a call expression
    if !(call_expr isa Expr && call_expr.head == :call)
        error("@server expects a function definition with a name")
    end

    # Extract function name
    func_name = call_expr.args[1]
    if !(func_name isa Symbol)
        error("@server function name must be a simple identifier")
    end

    func_name_str = string(func_name)

    # Generate the code that:
    # 1. Defines the function
    # 2. Registers it with the server function registry
    quote
        # Define the function normally
        $(esc(expr))

        # Register it with the server function registry
        register_server_function($func_name_str, $(esc(func_name)))

        # Return the function for convenience
        $(esc(func_name))
    end
end

"""
    generate_client_stub(name::String, arg_names::Vector{Symbol})

Generate JavaScript code for a client-side function stub.

This is useful for generating typed client-side code that calls server functions.
The stub wraps `TherapyWS.callServer` with proper argument handling.

# Example
```julia
js_code = generate_client_stub("get_user", [:id])
# Returns:
# "async function get_user(id) { return await TherapyWS.callServer('get_user', [id]); }"
```
"""
function generate_client_stub(name::String, arg_names::Vector{Symbol})
    args_str = join(string.(arg_names), ", ")
    args_array = isempty(arg_names) ? "[]" : "[" * join(string.(arg_names), ", ") * "]"

    """
    async function $(name)($(args_str)) {
        return await TherapyWS.callServer('$(name)', $(args_array));
    }
    """
end

"""
    server_function_stubs_script(names::Vector{String})

Generate a script tag with JavaScript stubs for the specified server functions.

This allows typed access to server functions from client-side JavaScript:

```julia
# Generate stubs for specific functions
script = server_function_stubs_script(["get_user", "create_post"])

# Include in page head
render_page(App(); head_extra = [server_functions_client_script(), script])
```

The generated JavaScript provides async functions that wrap TherapyWS.callServer.
"""
function server_function_stubs_script(names::Vector{String}=String[])
    # If no names provided, generate stubs for all registered functions
    if isempty(names)
        names = list_server_functions()
    end

    stubs = String[]
    for name in names
        sf = get_server_function(name)
        if sf !== nothing
            # Generate argument names based on arg_count
            arg_names = if sf.arg_count <= 0
                Symbol[]
            else
                [Symbol("arg$i") for i in 1:sf.arg_count]
            end
            push!(stubs, generate_client_stub(name, arg_names))
        end
    end

    if isempty(stubs)
        return RawHtml("")
    end

    RawHtml("""
<script>
// Server Function Client Stubs (generated by Therapy.jl)
$(join(stubs, "\n"))
</script>
""")
end
